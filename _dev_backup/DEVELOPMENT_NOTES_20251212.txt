================================================================================
AI SMART SCHEDULER - DEVELOPMENT NOTES
================================================================================
Date: December 12, 2025
Author: Development Team

================================================================================
1. DOCKERFILE OPTIMIZATION
================================================================================

1.1 Problem
-----------
- Original Dockerfile was inefficient with large image size
- Slow build times due to poor layer caching
- Missing runtime dependencies (libgomp1)

1.2 Solution - Multi-Stage Build
--------------------------------
- Stage 1 (Builder): Install build dependencies and Python packages
- Stage 2 (Runtime): Copy only necessary files with slim base image

1.3 Changes Made
----------------
- Base image: python:3.10-slim (approximately 60% size reduction)
- Added build-essential in builder stage for package compilation
- Added libgomp1 runtime dependency for spaCy/NumPy
- Set PYTHONUNBUFFERED=1 and PYTHONDONTWRITEBYTECODE=1 for better logging
- Optimized layer caching by copying requirements.txt first

================================================================================
2. FRONTEND TIMEOUT FIX
================================================================================

2.1 Problem
-----------
- Enhance button showed infinite loading when Gemini API timed out
- Gemini 2.5 Flash had 600-second (10 minute) timeout
- Frontend had no timeout handling, causing UI to hang indefinitely

2.2 Root Cause Analysis
-----------------------
- Terminal log showed:
  21:02:48 - POST /extract completed (spaCy extracted 2 schedules)
  21:12:44 - Gemini 2.5 failed with 600s timeout
  21:22:38 - POST /enhance-schedules completed (20 minutes total)

2.3 Solution
------------
- Added 30-second AbortController timeout to enhanceTitleAsync()
- Added 30-second AbortController timeout to enhanceSchedulesAsync()
- Both functions now properly reset button state on timeout

2.4 Code Changes (static/index.html)
------------------------------------
- Line 2405-2455: enhanceTitleAsync() with timeout controller
- Line 2457-2510: enhanceSchedulesAsync() with timeout controller

================================================================================
3. PERFORMANCE OPTIMIZATION - PHASE 1
================================================================================

3.1 Identified Bottlenecks
--------------------------
a) spaCy model called multiple times on same text:
   - run_ner_extraction() at line 1407
   - models["nlp_sm"](translated_text) at line 1414 (duplicate)
   - extract_multiple_schedules_with_spacy() at line 1440

b) GoogleTranslator instance created on every call:
   - translate_korean_to_english() created new instance each time
   - translate_english_to_korean() created new instance each time

c) No caching for repeated translations

3.2 Solutions Implemented
-------------------------

a) Translation Caching with lru_cache:
   - Added @lru_cache(maxsize=256) to _cached_translate_ko_en()
   - Added @lru_cache(maxsize=256) to _cached_translate_en_ko()

b) GoogleTranslator Singleton Pattern:
   - Created global _translator_ko_to_en and _translator_en_to_ko
   - Added _get_translator_ko_en() and _get_translator_en_ko() getters
   - Instances created once, reused for all calls

c) spaCy Doc Object Reuse:
   - Modified run_ner_extraction() to return doc as 7th value
   - Modified process_text_schedule() to reuse spacy_doc
   - Eliminated duplicate nlp_sm(translated_text) call

================================================================================
4. PERFORMANCE OPTIMIZATION - PHASE 2
================================================================================

4.1 Additional Optimizations (Accuracy Preserved)
-------------------------------------------------

a) Pre-compiled Regex Patterns:
   - Created _DATE_PATTERNS_COMPILED global constant
   - All 6 date patterns pre-compiled at module load
   - Eliminates re.compile() overhead on every function call

b) Dateparser Result Caching:
   - Added _cached_dateparse() with @lru_cache(maxsize=512)
   - Caches YYYY-MM-DD results for repeated date strings

================================================================================
5. BENCHMARK RESULTS
================================================================================

5.1 Test Cases
--------------
- Single Schedule (English): "Meeting tomorrow at 3pm at Starbucks"
- Single Schedule (Korean): Korean translation of above
- Multiple Schedules (English): 3 events with different times/locations
- Multiple Schedules (Korean): Korean translation of above

5.2 Performance Comparison
--------------------------
                          BEFORE      AFTER       IMPROVEMENT
Single Schedule (EN)      2.71s       2.06s       -24%
Single Schedule (KO)      4.23s       2.36s       -44%
Multiple Schedules (EN)   2.25s       2.09s       -7%
Multiple Schedules (KO)   9.70s       7.55s       -22%

5.3 Key Findings
----------------
- Korean processing showed largest improvement (44% for single schedule)
- Translation caching was the most impactful optimization
- Phase 2 optimizations (regex, dateparser) had minimal additional impact
  because Phase 1 already addressed the main bottleneck (translation)

================================================================================
6. FILES MODIFIED
================================================================================

6.1 main.py
-----------
- Lines 75-125: Added translation caching and singleton pattern
- Lines 513-545: Added pre-compiled regex and dateparser cache
- Line 638: Updated run_ner_extraction() return value (7 values)
- Line 765: Updated return statement to include doc
- Lines 1405-1420: Updated process_text_schedule() to reuse spacy_doc

6.2 static/index.html
---------------------
- Lines 2405-2455: enhanceTitleAsync() with 30s timeout
- Lines 2457-2510: enhanceSchedulesAsync() with 30s timeout

6.3 Dockerfile
--------------
- Complete rewrite with multi-stage build
- Lines 1-15: Builder stage
- Lines 17-51: Runtime stage

6.4 benchmark.py (NEW)
----------------------
- Performance testing script
- 4 test cases with configurable iterations
- JSON output with timestamps

================================================================================
7. DEPLOYMENT
================================================================================

7.1 Git Commit
--------------
Commit: 98841cc
Message: "Performance Optimization & Bug Fixes"
Files: 4 files changed, 391 insertions(+), 180 deletions(-)

7.2 Hugging Face Push
---------------------
Successfully pushed to origin/master
Spaces auto-build triggered

================================================================================
8. TECHNICAL NOTES
================================================================================

8.1 Why Translation Caching Works
---------------------------------
- Same Korean input text is often analyzed multiple times
- First call takes full translation time (API call)
- Subsequent calls return cached result (microseconds)
- lru_cache with maxsize=256 provides good hit rate without memory issues

8.2 Why spaCy Doc Reuse Matters
-------------------------------
- spaCy model processing is CPU-intensive
- Creating doc object requires tokenization, parsing, NER
- Reusing doc eliminates redundant processing
- Particularly important for multiple schedule detection flow

8.3 Timeout Strategy
--------------------
- 30 seconds chosen as reasonable balance
- Long enough for most Gemini responses
- Short enough to prevent UI hanging
- AbortController is native browser API (no dependencies)

================================================================================
END OF DEVELOPMENT NOTES
================================================================================
